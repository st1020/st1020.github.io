[{"categories":["计算机"],"content":"BrainFuck BrainFuck 语言是一种深奥的编程语言（Esoteric programming language， Esolang），由 Urban Müller 于1993年创造。目的是为了创造一个简单的、最小的、符合图灵完全的编程语言。正如它的名字，BrainFuck 因为对人类极度不友好而广为人知。但是作为一种图灵完备的编程语言，理论上任何其他编程语言能够实现的程序都可以由 BrainFuck 实现。 BrainFuck 基于一种简单的机器模型，这个机器包括八种指令，一个以字节（0-255）为单位、初始全部为零的数组，一个初始时指向该数组中第一个字节的指针，以及用于输入输出的两个字节流。 八种指令用字符表示如下： 字符 含义 \u003e 指针前进一个字节 \u003c 指针后退一个字节 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（根据ASCII码） , 输出指针指向的单元内容（根据ASCII码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 注意，在对数组的字节进行加减时有两种特殊的规则： $0-1=255$ $255+1=0$ 并且数组本身向前是无限的（或者说限制就是这种机器的内存），但并不能反向延伸，也就是说，初始时，指针只能向前移动而不能向后。 我们可以仅仅根据以上的规则写一些简单的程序： ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:1:0","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"代码实例 目前位置归零 [-] 字符输入输出 ,. 小写字符转化为大写 ,----------[----------------------.,----------] Hello World! ++++++++++[\u003e+++++++\u003e++++++++++\u003e+++\u003e+\u003c\u003c\u003c\u003c-]\u003e++.\u003e+.+++++++..+++.\u003e++.\u003c\u003c+++++++++++++++.\u003e.+++.------.--------.\u003e+.\u003e. 加法器 \u003e\u003e[-]\u003e[-]\u003c\u003c\u003c// clear cell #2 and #3 [-\u003e\u003e+\u003e+\u003c\u003c\u003c]// transfer cell #0 to #2 and #3 \u003e\u003e\u003e[-\u003c\u003c\u003c+\u003e\u003e\u003e]\u003c\u003c// transfer cell #3 to #0 [-\u003e+\u003e+\u003c\u003c]// transfer cell #1 to #2 and #3 \u003e\u003e[-\u003c\u003c+\u003e\u003e]\u003c\u003c// transfer cell #3 to #1 \u003c 乘法器 \u003e\u003e[-]\u003e[-]\u003e[-]\u003c\u003c\u003c\u003c// clear cell #2 and #3 and #4 [-\u003e[-\u003e+\u003e+\u003c\u003c]// add cell #1 to #2 and #3 \u003e\u003e[-\u003c\u003c+\u003e\u003e]// move cell #3 back to #1 \u003e+\u003c// copy cell #0 to #4 \u003c\u003c\u003c]\u003e\u003e\u003e\u003e[-\u003c\u003c\u003c\u003c+\u003e\u003e\u003e\u003e]\u003c\u003c\u003c\u003c// move cell #4 back to #0 ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:1:1","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"代码分析 下面以 Hello World! 程序为例分析一下 BrainFuck 程序的运行过程： ++++++++++将0号字节（第一个字节，以下简称#0）加到10 [开始循环 \u003e+++++++#1加到7 \u003e++++++++++#2加到10 \u003e+++#3加到3 \u003e+#4加到1 \u003c\u003c\u003c\u003c-返回#0并减1 ]由于此时指针位于#0，所以当#0减至0时就退出循环 循环共运行10次，至此数组的内容为：0/70/100/30/10 \u003e++.进入#1，加2，此时#1为72，输出 'H'，以下同理 \u003e+.输出 'e' +++++++.输出 'l' .输出 'l' +++.输出 'o' \u003e++.输出 ' ' \u003c\u003c+++++++++++++++.输出 'W' \u003e.输出 'o' +++.输出 'r' ------.输出 'l' --------.输出 'd' \u003e+.输出 '!' \u003e.输出 '\\n' ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:1:2","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"Python实现 我使用 Python 实现的 Brainfuck 解释器代码如下： # Python 实现的 Brainfuck 解释器 test = '++++++++++[\u003e+++++++\u003e++++++++++\u003e+++\u003e+\u003c\u003c\u003c\u003c-]\u003e++.\u003e+.+++++++..+++.\u003e++.\u003c\u003c+++++++++++++++.\u003e.+++.------.--------.\u003e+.\u003e.' test1 = ',----------[----------------------.,----------]' def bf_interpreter(bf_code): main_list = [0] now_id = 0 now_position = 0 while now_position \u003c len(bf_code): command = bf_code[now_position] if command == '\u003c': if now_id == 0: print_error(1, '内存错误，指针位于-1') else: now_id -= 1 elif command == '\u003e': now_id += 1 if now_id \u003e= len(main_list): main_list.append(0) elif command == '+': main_list[now_id] += 1 if main_list[now_id] == 256: main_list[now_id] = 0 elif command == '-': main_list[now_id] -= 1 if main_list[now_id] == -1: main_list[now_id] = 255 elif command == '.': print(chr(main_list[now_id]), end='') elif command == ',': while True: input_chr = input('请输入：') if len(input_chr) == 1: if ord(input_chr) \u003c 128: main_list[now_id] = ord(input_chr) break else: print_error(2, '输入错误，只能输入ASCII字符') else: print_error(2, '输入错误，只能输入一个字符') elif command == '[': if main_list[now_id] == 0: try: now_position = bf_code.index(']', now_position) - 1 except ValueError: print_error(3, '代码错误，缺失：]') elif command == ']': if main_list[now_id] != 0: try: now_position = len(bf_code) - bf_code[::-1].index('[', len(bf_code) - now_position - 1) - 1 except ValueError: print_error(3, '代码错误，缺失 [') else: print_error(0, '无法解析的字符：' + command) now_position += 1 print(main_list) def print_error(error_code, msg): print(error_code, msg) if __name__ == '__main__': bf_interpreter(test) 程序十分简单，主要就是使用一个while循环来执行 BrainFuck 代码的解析，并使用一个list来作为进行操作的数组。 至于这个程序以及 Brainfuck 语言到底有什么用处，毕竟不会真的有人会拿它写代码的，实际上，这个问题就像哥德巴赫猜想有什么用一样，它确实并不会在我们的实际生活生产有任何应用，但是，黎曼在创建黎曼几何也不知道它能被应用到相对论的数学描述中，也许未来的某一天我们遇到了一个真的用 Brainfuck 编程的外星人呢，并且这确实很有趣，至少很酷，不是吗？ 当然，Brainfuck 并非是唯一一种 Esolang，也不是其中规则最简单或是最奇怪的，其实也不是最让人感到“Brainfuck”的，这世界上总有一群有趣的人设计出各种奇奇怪怪的语言。 ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:2:0","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"彩蛋 最后，你想要做一个巧克力酱蛋糕吗？下面是菜谱，不保证口味哦～ Hello World Cake with Chocolate sauce. This prints hello world, while being tastier than Hello World Souffle. The main chef makes a \" world!\" cake, which he puts in the baking dish. When he gets the sous chef to make the \"Hello\" chocolate sauce, it gets put into the baking dish and then the whole thing is printed when he refrigerates the sauce. When actually cooking, I'm interpreting the chocolate sauce baking dish to be separate from the cake one and Liquify to mean either melt or blend depending on context. Ingredients. 33 g chocolate chips 100 g butter 54 ml double cream 2 pinches baking powder 114 g sugar 111 ml beaten eggs 119 g flour 32 g cocoa powder 0 g cake mixture Cooking time: 25 minutes. Pre-heat oven to 180 degrees Celsius. Method. Put chocolate chips into the mixing bowl. Put butter into the mixing bowl. Put sugar into the mixing bowl. Put beaten eggs into the mixing bowl. Put flour into the mixing bowl. Put baking powder into the mixing bowl. Put cocoa powder into the mixing bowl. Stir the mixing bowl for 1 minute. Combine double cream into the mixing bowl. Stir the mixing bowl for 4 minutes. Liquify the contents of the mixing bowl. Pour contents of the mixing bowl into the baking dish. bake the cake mixture. Wait until baked. Serve with chocolate sauce. chocolate sauce. Ingredients. 111 g sugar 108 ml hot water 108 ml heated double cream 101 g dark chocolate 72 g milk chocolate Method. Clean the mixing bowl. Put sugar into the mixing bowl. Put hot water into the mixing bowl. Put heated double cream into the mixing bowl. dissolve the sugar. agitate the sugar until dissolved. Liquify the dark chocolate. Put dark chocolate into the mixing bowl. Liquify the milk chocolate. Put milk chocolate into the mixing bowl. Liquify contents of the mixing bowl. Pour contents of the mixing bowl into the baking dish. Refrigerate for 1 hour. ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:3:0","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"参考 Brainfuck - 维基百科 深奥的编程语言 - 维基百科 ","date":"2020-09-14","objectID":"/a-brainfuck-language-interpreter-implemented-in-python/:4:0","tags":["Python","Esolang"],"title":"Python 实现的 Brainfuck 语言解析器","uri":"/a-brainfuck-language-interpreter-implemented-in-python/"},{"categories":["计算机"],"content":"停机问题是是逻辑数学中可计算性理论的一个很经典的问题，该问题内容为：是否存在一个程序H，对于任意输入的程序P，能够判断P会在有限时间内结束或者死循环。 答案是否定的，证明如下： 假设停机问题有解，即存在一个程序能够判断程序P在输入I的情况下是否可停机（即是否会进入死循环）。我们假设该程序为高阶函数（Higher-order function）H，即： def H(P, I) -\u003e bool: pass 若函数P不会进入死循环，则H返回True，否则返回False。 然后我们定义另一个函数U： def U(P): if H(P, P): while True: pass else: return 也就是说当H判断P(P)会停机时，U就进入死循环，否则正常返回。 注意，因为在计算机当中所谓函数也是一串数据，所以将自身作为输入输入自身是完全没有问题的。 那么，当U输入U，也就是U(U)会不会停机呢？既然H能够判断任何程序是否会停机，那么应该也能回答这个问题，也就是： H(U, U) 那么问题就来了，如果H认为U(U)会停机，即H(U, U)返回True，那么实际上U(U)就会进入死循环，并不会停机。如果H认为U(U)不会停机，即H(U, U)返回False，那么实际上U(U)就会进入死循环，并不会停机。这就推出了矛盾，也就是说H并不能永远给出停机问题的准确答案。 由此可以证明，不存在能够判断任意程序在特定输入下是否会在有限时间内停机的程序，停机问题无解。 于此类似的还有“理发师悖论”：一位理发师的原则是当且仅当一个人不为自己理发时他为其理发，那么这位理发师能为自己理发吗？这里“理发师悖论”实际上是罗素悖论的一个比喻，也即：对于集合$A=\\{x \\mid x \\notin x\\}$判断$A \\in A$是否成立。 这个悖论的根本性问题为集合的自指，所以我们只要拒绝集合的自指即可解决该问题，也就是认为不存在像$\\{x \\mid x \\notin x\\}$的集合。 同样，对于停机问题我们也可以有类似的解释，产生悖论的原因正是这个能够判断其他程序是否能停机的程序也是一个程序，那么当它判断涉及自己的程序时就可能会产生悖论，最终证明一个程序不可能判断其他所有程序是否停机。 类似的还有“全能悖论”：上帝全知全能，那么祂能创造一个自己搬不起来的石头吗？如果能，那么说明其在力量方面并非全能，如果不能，说明其在创造方面并非全能。这同样是因为自指导致的悖论，当我们将上帝的全能性作用于其本身时就会导致悖论，从而说明全能的上帝是不存在的。 此外还有一个最常见的悖论——“说谎者悖论”：“这个语句为假”是否为真。对此有许多解释，比如曾有人提出应拒绝与排中律有关的二值原理，也就是拒绝“所有语句要么为真要么为假”的主张，认为其非真非假。但是，对于另一个问题：“这个语句不为真”是否为真，也同样无法解决，类似的主张如认为其又真又假也存在无法回答的问题，即”这个语句只为假“是否为真。对此的解决比较好的有Arthur Prior提出的观点：语句都包含对自己真值的隐含断言，即“一加一等于二”隐含了“一加一等于二为真”的真值断言，任何一句话“A”都可以改写为“A且这句话为真”，那么同样，“这句话为假”等价与“这句话为真且这句话为假”，而这句话本身就包含了矛盾，就像“这个东西是苹果且这个东西不是苹果”一样，所以说谎者悖论实质上是由一个一开始就含有矛盾的假语句而推导出的另一个矛盾，并不是一个悖论。不过我认为这实质上是从语言上回避了这个这个问题，是因为自然语言的不严谨导致的，并无法用来解释罗素悖论等其他涉及自指的悖论。 除此之外还有很多涉及自指的悖论，比如著名的哥德尔不完备性定理：任何兼容的形式系统，只要蕴涵皮亚诺算术公理，就是不完备的并且不能用于证明它本身的兼容性。它的证明过程同样是在体系内部构造自指性悖论。实际上，停机问题、罗素悖论（理发师悖论）、全能悖论、哥德尔不完备性定理等悖论的实质都是是一阶逻辑的不完备性。 我们平常看似严谨且精确的逻辑体系与数学体系也并非是完美的，我并不知道是否像大卫‧希尔伯特在1920年代提出的希尔伯特计划所希望的一样，存在一种完全严谨、完备、兼容的逻辑体系，如果存在又是否能够被人类的理性所认识，以及其是否还是“逻辑”，但我相信人类对于任何事物的认识都是不断深入的，逻辑学也是如此，“我们必须知道，我们必将知道”，即使结果可能并非完美。 ","date":"2020-07-21","objectID":"/halting-problem-and-self-reference-paradox/:0:0","tags":["逻辑","计算机","悖论"],"title":"关于停机问题与自指性悖论","uri":"/halting-problem-and-self-reference-paradox/"},{"categories":["Hugo"],"content":"由于各种原因，已经很久没有更新博客了…鸽子真快乐。总之，从今天起，本博客正式迁移至 Hugo！ 其实在开始建立这个博客的时候我就已经想要使用 Hugo 作为静态博客生成器了，只是一直没有找到满意的主题，所以就搁置了下来，直到最近我终于找到了一个可以说非常完美的主题：LoveIt，于是果断将博客迁移到了 Hugo 上了。 Hugo 在很多方面都要比 Hexo 更加方便，首先，Hugo 的环境配置十分简单，只需要一个 Go 语言编译的可执行文件即可执行，而 Hexo 则需要安装 Node.js 环境。其次，Hugo 的运行速度更快，相比于 Hexo 最短也要几秒到几十秒的构建时间，Hugo 只需要几百毫秒即可完成构建。其三，Hugo 的目录配置更加合理，Hugo 的没有像 Hexo 那样的使用 node_modules 管理插件，主题目录与站点目录结构相同，文章与静态文件分开存放，不区分站点与主题配置文件，使用文件系统结构来组织文章等等。 当然，Hexo 也并非一无是处，其主题资源相较 Hugo 要更加丰富，用户数量也更多。但是综合考虑我还是选择了 Hugo。 最后，再见 Hexo，你好 Hugo！ Farewell Hexo, Hello Hugo! ","date":"2020-07-15","objectID":"/powered-by-hugo/:0:0","tags":["Hugo","Blog"],"title":"Powered by Hugo","uri":"/powered-by-hugo/"},{"categories":["Hexo"],"content":"本篇文章主要谈一谈我是如何个性化定制 Hexo 的NexT 主题的。 Hexo 的主题有许多种，其中最知名的莫过于 NexT 主题了，我也选择了这款主题作为我的博客的默认主题。实际上，我本来是打算使用 Hugo 来搭建博客的，但苦于没有找到喜欢的主题，只好作罢。如果未来找到了足够好的主题，我应该会将博客迁移到 Hugo 上吧。本篇也是作为我折腾 Hexo 的一篇记录。 注意 自2020年7月15日起，本博客已经由 Hexo 迁移到了 Hugo，本文部分内容已经不适用了，你可以点击这里下载本博客最后版本的 Hexo 源码。 注意 本文基于 NexT 主题 7.8.0 版本，理论上适用于 NexT 7.0+ 。 下文中网站的配置文件指 Hexo 根目录下的_config.yml，主题的配置文件位置取决于你的主题配置情况。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:0:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"Hexo 搭建和主题安装 关于 Hexo 搭建和主题安装的教程可以说是数不胜数了，我这里就不做赘述了。我使用了 Github page 来储存发布网页，同时同步到 Zeit.co 上作为镜像，并且将 st1020.top 域名解析到这两个网址，让 DNS 自动选择线路。许多其他教程还同时部署到了 Coding 来加速国内的访问，我并没有这么做，主要懒得再注册一个账户了，并且实际测试下来网站的访问速度还在可以接受的范围内。如果你想要查看我的博客配置，可以访问我的 Gtihub 。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:1:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"安装插件 Hexo 支持很多方便的插件，我安装的主要如下： hexo-cake-moon-menu hexo-deployer-git hexo-generator-feed hexo-generator-searchdb hexo-generator-sitemap hexo-related-popular-posts hexo-renderer-pandoc hexo-symbols-count-time 其配置可直接参看 NexT 主题文档和上面的插件链接。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:2:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"hexo-cake-moon-menu hexo-cake-moon-menu 是一款来自 hexo-theme-inside 主题的悬浮菜单模块，支持自定义菜单项。我打算为其增加夜间模式和简体/繁体自动切换的功能。由于我之前对 Web 前端开发基本上是一窍不通的，所以下面的过程可能有不恰当的地方，还请各位见谅。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:3:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"配置方法 根据 Github 上的方法，自定义 hexo-cake-moon-menu 需要自己编写 JS 插件脚本进行注入，修改布局文件，再修改网站配置文件，看起来很复杂，但好在 NexT 主题已经提供自定义布局的方法，我们只需要修改主题的配置文件中的custom_file_path:配置即可。 而对于 hexo-cake-moon-menu 插件的配置，按照作者的说明是这样的： moon_menu:chat:icon:fa fa-commentsfunc:openGitter 其中icon参数为该项的图标，可以在 Font Awesome 中找到，func则为点击这一项时运行的 JavaScript 函数名。所以我们的大体思路就是： 编写一个 JavaScript 脚本实现相关功能 添加自定义布局，使网页加载对应的脚本 修改配置文件，指向相应的函数 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:3:1","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"添加 简体/繁体转换 关于这个功能的实现，网上已经有了相关脚本了，我参考的是这篇教程： 两步让你的网站支持简体繁体切换 其中提供了一个简繁转换的脚本，我在此基础上做了一点修改，功能上应该是相同的，可以点击这里下载，如果想要下载原脚本的话可以访问上面的网站。 首先下载上面的脚本，放在/source/js/tw_cn.js 。 然后我们需要修改主题的配置文件，找到其中的custom_file_path:选项，把下面这行反注释： footer:source/_data/footer.swig 然后新建/source/_data/footer.swig文件，写入： \u003cdiv class=\"translate-style\"\u003e繁/简：\u003ca id=\"translateLink\" href=\"javascript:translatePage();\"\u003e繁体\u003c/a\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"/js/tw_cn.js\"\u003e\u003c/script\u003e 这相当于在每个网页的footer部分都添加了上面两行 HTML 代码，第一行表示创建一个\u003cdiv\u003e ，里面包含两部分，一部分是文字繁/简： ，另一部分是一个超链接，id为\"translateLink\" ，点击后会运行 JS 函数translatePage() ，第二行就是引入/js/tw_cn.js脚本。 如果你使用的是原来的 JS 脚本而非我修改的那个的话，还需要按照上面的地址中的教程添加一些配置项，如果是用我修改的那个话就什么都不用做了。 最后，我们需要修改网站配置文件，加入以下代码： moon_menu:zh:icon:fas fa-atlasfunc:translatePage 这样，简繁切换菜单就添加完成了。如果你不想要在页脚显示的话还需要修改一下 JS 脚本，去掉里面关于更改文字的代码。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:3:2","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"夜间模式 NexT 主题是自带了夜间模式支持的，但是只支持根据系统的夜间模式与否来切换，并不是很方便，于是我打算自己写一个来代替原来的夜间模式，实现根据系统的夜间模式和时间自动切换，同时支持使用 hexo-cake-moon-menu 手动切换。 首先，我们需要知道 NexT 主题自带的夜间模式是怎么实现的，我们可以在/theme/next/source/css/_colors.styl中找到以下内容： :root { --body-bg-color: $body-bg-color; --content-bg-color: $content-bg-color; --card-bg-color: $card-bg-color; --text-color: $text-color; ... } if (hexo-config('darkmode')) { @media (prefers-color-scheme: dark) { :root { --body-bg-color: $body-bg-color-dark; --content-bg-color: $content-bg-color-dark; --card-bg-color: $card-bg-color-dark; --text-color: $text-color-dark; ... } img { opacity: .75; \u0026:hover { opacity: .9; } } } } 上面的 CSS 代码使用了:root选择器@media查询，当浏览器配置为prefers-color-scheme: dark时便会设置为夜间模式的配色，并且设置图片透明度增加，不过需要注意的是，我们并不能直接使用上面的代码，因为后面对应的并非颜色，而是变量，会在渲染时替换为颜色，我们可以在/theme/next/source/css/_variables/base.styl中找到变量对应的颜色，不过手动替换太麻烦了，我选择在主题配置文件中设置darkmode: true，运行hexo g生成静态文件，然后在/public/css/main.css中找到需要的 CSS 代码，得到的代码如下： :root { --body-bg-color: #282828; --content-bg-color: #333; --card-bg-color: #555; --text-color: #ccc; --blockquote-color: #bbb; --link-color: #ccc; --link-hover-color: #eee; --brand-color: #ddd; --brand-hover-color: #ddd; --table-row-odd-bg-color: #282828; --table-row-hover-bg-color: #363636; --menu-item-bg-color: #555; --btn-default-bg: #222; --btn-default-color: #ccc; --btn-default-border-color: #555; --btn-default-hover-bg: #666; --btn-default-hover-color: #ccc; --btn-default-hover-border-color: #666; } img { opacity: 0.75; } img:hover { opacity: 0.9; } 我们把上面的代码保存在/source/css/dark.css中备用。 下面我们要做的就是让网站在合适的情况下加载dark.css，我参考了 网站夜间模式的实现 这篇文章，这篇文章是用于动态网站的，不过大同小异，思路都是一致的。 首先，我们要编辑主题配置文件，把下面这行反注释： head:source/_data/head.swig 然后新建/source/_data/head.swig文件，写入： \u003clink href=\"/css/dark.css\" rel=\"alternate stylesheet\" type=\"text/css\" title=\"dark\"\u003e \u003cscript type=\"text/javascript\" src=\"/js/darkmode.js\"\u003e\u003c/script\u003e 上面两行表示引入了/css/dark.css和/js/darkmode.js，注意第一行的rel属性为alternate stylesheet，表示将/css/dark.css作为备用 CSS ，默认并不启用。还有要注意的是，这两行的内容不能调换，必须先引入 CSS 再引入 JS ，因为 JS 是对 CSS 进行操作的，如果先引入 JS 的话，它就没有可操作的对象了。 还要，之所以我们把这两行写入了head.swig而非像简繁转换一样写入footer.swig，是因为简繁转换可以在页面其他部分加载完后再运行，而夜间模式则应该在页面加载前就运行了，否则会导致页面加载过程中一直是亮色的，页面加载完成后才变为夜间模式。 然后我们就可以开始编写 JS 脚本了。 首先我们来实现手动切换部分。我们可以使用以下代码来启用或禁用dark.css： //启用夜间模式 document.querySelector('link[title=\"dark\"]').disabled = true; document.querySelector('link[title=\"dark\"]').disabled = false; //关闭夜间模式 document.querySelector('link[title=\"dark\"]').disabled = false; 然后我们可以写一个函数实现切换功能： var night = 0 function switchDarkMode(){ if(night == 0){ document.querySelector('link[title=\"dark\"]').disabled = true; document.querySelector('link[title=\"dark\"]').disabled = false; var night = 1 }else{ document.querySelector('link[title=\"dark\"]').disabled = true; document.cookie = \"dark=0;path=/\" var night = 0 } } 但是上面的函数有一个问题，那就是只能在一个页面生效，当读者刷新了页面或这访问了其他的页面后就又会恢复为亮色模式了。那么有什么办法能够在整个网站中传递信息呢，很简单，那就是 cookie 。我们可以通过设置 cookie 来实现对整个网站设置夜间模式，修改后的代码如下： function switchDarkMode(){ var night = document.cookie.replace(/(?:(?:^|.*;\\s*)dark\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\") || '0'; if(night == '0'){ document.querySelector('link[title=\"dark\"]').disabled = true; document.querySelector('link[title=\"dark\"]').disabled = false; document.cookie = \"dark=1;path=/\" }else{ document.querySelector('link[title=\"dark\"]').disabled = true; document.cookie = \"dark=0;path=/\" } } 函数内的第一行表示读取 cookie 并使用正则表达式取出名称为dark的 cookie 的值，如果没有设置 cookie 那么就设置night变量为'0'，之后，在每次运行函数后设置对应的 cookie 。 最后我们就可以编辑网站配置文件给 hexo-cake-moon-menu 添加配置项： moon_menu:dark:icon:fas fa-adjustfunc:switchDarkMode 这样手动切换功能就完成了，下面我们来继续完成自动切换部分。 首先，手动切换的优先级肯定是要高于自动切换的，那么我们就要首先判断是否定义了 cookie ，如果定义了就使用定义的，没定义就判断时间和系统情况。注意，由于我们在上面设置 cookie 时没有设置持续时间，cookie 是会在浏览器会话结束后自动清除的。代码如下： if(document.cookie.replace(/(?:(?:^|.*;\\s*)dark\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\") == ''){ //判断时间和系统情况 } }else{ if(document.cookie.replace(/(?:(?:^|.*;\\s*)dark\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\") == '1'){ document.querySelector('link[title=\"dark\"]').disabled = true; document.querySelector('link[title=\"dark\"]').disabled = false; } } 然后，","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:4:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"一言 一言（hitokoto.cn）是一个分享一句话的平台，提供了一个很方便的 API 来进行访问，我设置了在我的网站首页显示一言，你可以在我的网站首页的侧边栏中查看实现效果。 添加一言相对来说比较简单，官方不仅提供了 API 还提供了示例代码，可以访问一言开发者中心查看详情。但官方的示例只获取了句子内容，我稍微修改了以下，让它也同时获取句子来源。 接下来我们需要自定义侧边栏，和上面一样，还是反注释主题配置文件中的sidebar: source/_data/sidebar.swig并新建/source/_data/head.swig文件。 一言部分我直接使用了和友情链接（blogroll）相同的样式，代码如下： \u003cdiv class=\"links-of-blogroll motion-element\"\u003e \u003cdiv class=\"links-of-blogroll-title\" id=\"hitotitle\"\u003e \u003ci class=\"fa fa-paragraph\"\u003e\u003c/i\u003e \u003cb\u003e一言\u003c/b\u003e \u003c/div\u003e \u003cp id=\"hitokoto\" style=\"padding: 0; margin: 0;\"\u003e:D 获取中...\u003c/p\u003e \u003cp id=\"hitofrom\" style=\"font-style: italic; text-align: right; padding: 0; margin: 0;\"\u003e:D 获取中...\u003c/p\u003e \u003cscript\u003e if(CONFIG.page.isHome){ fetch('https://v1.hitokoto.cn') .then(response =\u003e response.json()) .then(data =\u003e { const hitokoto = document.getElementById('hitokoto') const hitofrom = document.getElementById('hitofrom') hitokoto.innerText = data.hitokoto hitofrom.innerText = '——' + data.from }) .catch(console.error) }else{ document.getElementById('hitokoto').style.display =\"none\"; document.getElementById('hitofrom').style.display =\"none\"; document.getElementById('hitotitle').style.display =\"none\"; } \u003c/script\u003e \u003c/div\u003e 我设置为了仅在博客的首页显示，如果你需要在博客所有页面都显示的话可以将\u003cscript\u003e部分更换为以下代码： \u003cscript\u003e fetch('https://v1.hitokoto.cn') .then(response =\u003e response.json()) .then(data =\u003e { const hitokoto = document.getElementById('hitokoto') const hitofrom = document.getElementById('hitofrom') hitokoto.innerText = data.hitokoto hitofrom.innerText = '——' + data.from }) .catch(console.error) \u003c/script\u003e ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:5:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Hexo"],"content":"最后 你可能发现我的博客样式几乎就是 NexT 的 Gemini 主题的默认样式，并没有做什么更改。是的，我没有添加华丽的鼠标特效或是live2D的二次元看板娘，没有设置好听的背景音乐和特别的背景特效，甚至于连背景图片和字体都没有换。其实这都是因为我非常喜欢简约的风格，我认为博客最重要的是其内容，而主题的作用就是突出内容和帮助呈现内容，如果太过华丽就喧宾夺主了。我一直认为，最好的科技应该让人们察觉不到其存在，好的设计应该让人用起来很舒服，一切都是自然而然的，就像使用自己的四肢一样自然。 其实如果你细心观察的话，这个博客还是有一些自定义配置的，比如上面提到的简繁转换、夜间模式和首页的一言，还有 NexT 提供的网页顶部的阅读进度条、右上角会自动保存也能手动设置的书签、文章标题旁边的页面 Markdown 源码入口、点击图片后弹出的 FancyBox、延迟加载图片和自动缓存接下来的页面，以及由各种插件提供的右下角显示阅读进度百分比的悬浮菜单、侧边栏中的搜索功能、文章标题下面的字数统计和阅读时长、文章底部的 Gitalk 的评论。它们都是些不起眼的小功能，但都确确实实地方便了博客的浏览，这才是我需要的博客个性化配置。 ","date":"2020-04-09","objectID":"/hexo-next-theme-customization/:6:0","tags":["Hexo","Blog"],"title":"Hexo-NexT 主题个性化定制","uri":"/hexo-next-theme-customization/"},{"categories":["Linux"],"content":"前几天打开好久没用的电脑，一更新把之前图省事装的 Manjaro 滚挂了，也懒得去解决，于是决定安装一个 Arch Linux ，在这里记录一下安装过程。 本人是非常喜欢 Arch Linux 的，因为其高度自定义化、遵循KISS原则（Keep It Simple, Stupid）、滚动更新并且以用户为中心。但是，由于其理念为以用户为中心但不是用户友好，所以对很多人来说安装 Arch 还是有一定难度的。读者也可以参考本篇教程从零开始安装一个属于自己的 Arch 。 ","date":"2020-04-08","objectID":"/arch-install/:0:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"准备 ","date":"2020-04-08","objectID":"/arch-install/:1:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装介质 在安装之前我们需要首先准备一个U盘或者光盘作为安装介质。不过光盘这东西现在应该没人用了吧，那我就以U盘为例了。 下载镜像：Arch Linux Downloads下载 Arch Linux 镜像。为了提高下载速度，我是在TUNA（清华大学开源软件镜像站）下载的。 烧录镜像：我是在 Windows 下使用 Rufus 烧录的镜像，当然，也可以使用其他软件。 ","date":"2020-04-08","objectID":"/arch-install/:1:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"磁盘分区 为了方便我直接在Windows下分好了分区，我的电脑有一块 SSD 和一块机械硬盘，我打算在SSD挂载/，在机械硬盘挂载/home。所以我分别在两块硬盘的末尾空余出了一段空间，留作Arch使用。 ","date":"2020-04-08","objectID":"/arch-install/:1:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"开始安装 ","date":"2020-04-08","objectID":"/arch-install/:2:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"U盘启动 在 BIOS 或者 UEFI 中设置U盘为第一启动项，进入 Arch 菜单后选择Boot Arch Linux (x86_64)。 ","date":"2020-04-08","objectID":"/arch-install/:2:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"检查引导方式 可以使用以下命令检查引导方式为 BIOS(LEGACY)+MBR 还是 EFI/GPT 。 ls /sys/firmware/efi/efivars 我的电脑比较旧，仍使用的是 BIOS+MBR 。 ","date":"2020-04-08","objectID":"/arch-install/:2:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"联网 Arch 是不能离线安装的，必须要连接网络。 有线连接： dhcpcd 无线连接： Arch 并不一定能在此时支持所有型号的无线网卡，如果支持的话可以使用以下命令连接 Wifi ： wifi-menu 如果出现问题的话可以参见：Network configuration/Wireless 如果你的无线网卡无法支持，可以使用数据线将手机连接电脑，启用USB网络共享，然后就可以按照有线连接处理了。 ","date":"2020-04-08","objectID":"/arch-install/:2:3","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"更新系统时间 执行以下命令： timedatectl set-ntp true ","date":"2020-04-08","objectID":"/arch-install/:2:4","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"分区与格式化 危险 注意 数据无价，请谨慎操作！ 分区 使用以下命令查看目前的分区情况。 fdisk -l 使用以下命令进入交互式分区管理： cfdisk /dev/sdx 其中的x替换为你想要进行分区的硬盘，比如我就需要先执行cfdisk /dev/sda来处理 SSD ，然后再执行cfdisk /dev/sdb来处理机械硬盘。 分区的过程比较简单，按照界面中的提示来就好，最后不要忘了保存。 分区完成后再执行fdisk -l来确认一下分区信息。 格式化 使用以下命令对分区进行格式化： mkfs.ext4 /dev/sdxY 其中的 x y 替换为需要格式化的分区，比如mkfs.ext4 /dev/sda1 。 挂载分区 使用以下命令将根分区挂载到/mnt： mount /dev/sdxY /mnt 如果你像我一样额外创建了/home分区，还需要执行以下操作： mkdir /mnt/home mounrt /dev/sdxY /mnt/home ","date":"2020-04-08","objectID":"/arch-install/:2:5","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"更换镜像源 为了加快之后的软件包下载速度，我们需要先更换一下默认的镜像源。 编辑/etc/pacman.d/mirrorlist 。 nano /etc/pacman.d/mirrorlist 将你需要的镜像源剪切到文件的最上方，第一个镜像源将作为默认镜像源。 对于 nano 编辑器，你可以使用Ctrl+W快捷键来搜索，Alt+W来继续搜索下一个，Ctrl+K来剪切一整行，Ctrl+U粘贴，最后使用Ctrl+X来退出。 我推荐使用清华、浙大、中科大和网易的源。 Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = http://mirrors.163.com/archlinux/$repo/os/$arch ","date":"2020-04-08","objectID":"/arch-install/:2:6","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装基本包 执行以下命令： pacstrap /mnt base base-devel linux linux-firmware dhcpcd 其中base-devel如果你不使用 AUR 源的话可以不安装。 ","date":"2020-04-08","objectID":"/arch-install/:2:7","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"基础配置 ","date":"2020-04-08","objectID":"/arch-install/:3:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"Fstab 使用以下命令生成 fstab 文件： genfstab -L /mnt \u003e\u003e /mnt/etc/fstab 这步非常重要，决定了你能否正常启动系统，最好检查一下配置的是否正确。 cat /mnt/etc/fstab ","date":"2020-04-08","objectID":"/arch-install/:3:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"Chroot Change root 到新安装的系统，自此，我们运行的命令就全部在新的系统而非U盘里的临时系统中运行了： arch-chroot /mnt ","date":"2020-04-08","objectID":"/arch-install/:3:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"配置时区 使用以下命令将时区设置为东八区并生成/etc/adjtime文件： ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc ","date":"2020-04-08","objectID":"/arch-install/:3:3","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"本地化 首先编辑/etc/locale.gen文件，这个文件中应该只有注释，我们需要把要使用的语言反注释（即去掉最前面的#），建议只选择带有 UTF-8 的语言，比如： nano /etc/locale.gen en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 设置完成后，执行locale-gen生成 locale 信息。 之后，我们需要编辑/etc/locale.conf来设置系统的默认语言。 /etc/locale.conf 然后输入以下内容： LANG=en_US.UTF-8 信息 注意 不建议在这里直接设置为zh_CN.UTF-8 ，会造成 TTY 乱码以及一些log文件输出错误。 ","date":"2020-04-08","objectID":"/arch-install/:3:4","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"设置主机名 编辑/etc/hostname并在里面输入你的主机名。 然后编辑/etc/hosts，输入以下内容（将myhostname替换为你的主机名）： 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname.localdomain myhostname ","date":"2020-04-08","objectID":"/arch-install/:3:5","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"设置Root密码 为了安全，我们需要为root账户设定一个密码，直接输入以下命令，并输入两次不可见的密码，就设置好了。 passwd ","date":"2020-04-08","objectID":"/arch-install/:3:6","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装引导程序 只有一个系统是无法直接启动的，我们需要安装一个引导程序来启动我们的系统。对于 Linux 最流行的是 Grub2 。 识别其他系统 也许你的电脑中并不是只有 Arch 一个系统，那么我们应该让 Grub2 也能够管理其他系统，我们只需要先安装以下两个包就可以识别已经存在的系统了。 pacman -S os-prober ntfs-3g BIOS/MBR 依次执行以下的命令，来安装 Grub2 启动管理器： pacman -S grub grub-install --target=i386-pc /dev/sdx grub-mkconfig -o /boot/grub/grub.cfg 注意：其中的sdx应该是你的/（根目录）所在硬盘（不是分区，是硬盘！）。 EFI/GPT 依次执行以下的命令，来安装 Grub2 启动管理器： pacman -S grub efibootmgr grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub grub-mkconfig -o /boot/grub/grub.cfg 检查 为了确保万无一失，我们最好检查以下 Grub 配置是否正确。 nano /boot/grub/grub.cfg 检查是否正确配置了 Arch 启动项以及是否识别到了其他系统。 ","date":"2020-04-08","objectID":"/arch-install/:3:7","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"提前安装其他必要软件 在正式进入系统开始配置之前，我们也可以先安装一些必要的软件。 输入以下命令， pacman 会自动帮你处理好依赖等问题并完成安装。 pacman -S nano vim dialog wpa_supplicant ntfs-3g networkmanager 如果你是 Intel CPU 建议额外安装intel-ucode来安装 Intel 微代码固件。 pacman -S intel-ucode ","date":"2020-04-08","objectID":"/arch-install/:3:8","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"重启进入系统 至此， Arch Linux 的基本安装和配置就完成了，我们可以重启进入安装好的系统来进行进一步的配置。 首先，退出 Chroot 环境执，行如下命令： exit 依次卸载硬盘分区： umount /mnt/home umount /mnt 最后重启并在关机后拔掉U盘。 reboot ","date":"2020-04-08","objectID":"/arch-install/:3:9","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装后的配置 ","date":"2020-04-08","objectID":"/arch-install/:4:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"创建交换文件 对于现代的操作系统来说，交换文件是一种非常常见的设计，它将在物理内存不足时将部分硬盘空间模拟为内存，避免系统停止工作。在 Linux 中之前常见的做法是划分一个单独的分区作为交换分区，而目前更为便捷的做法是像 Windows 一样创建一个交换文件，方便之后的管理和调整。 首先分配一块空间用于交换文件： fallocate -l 512M /swapfile 推荐至少要有 4G 大小。 更改权限： chmod 600 /swapfile 设置交换文件： mkswap /swapfile 启用交换文件： swapon /swapfile 最后编辑/etc/fstab在开机时挂载交换文件： nano /etc/fstab 在最底部添加： /swapfile none swap defaults 0 0 ","date":"2020-04-08","objectID":"/arch-install/:4:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"新建用户 直接使用root账户作为默认账户是很不安全的，没准手一抖输入了个rm -rf /就和全部数据说拜拜了。并且很多软件都是禁止在root环境下执行的，比如安装 AUR 源中的软件时必须的makepkg命令。所以我们要创建一个低权限账户作为日常使用的账户。使用以下命令创建一个账户： useradd -m -G wheel username 上面的命令表示创建一个名为 username 的账户，加入 wheel 用户组，并为其创建一个用户主目录/home/username 。 之后执行以下命令设置密码。 passwd username ","date":"2020-04-08","objectID":"/arch-install/:4:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"配置sudo 如果我们要在低权限账户中执行一些特权操作，该怎么办呢，很简单，直接输入su命令即可切换到root账户，执行完后再输入exit即可返回，但是这样多少有些麻烦，我们可以用sudo命令来简化这一步骤。 首先安装sudo： pacman -S sudo 然后为了配置sudo ，需要先设置一个默认编辑器，比如 nano 或者 vim： export EDITOR=nano export EDITOR=vim 然后执行： visudo 找到# %wheel ALL=(ALL)ALL这行，并反注释掉。 这表示允许wheel用户组的全部用户使用sudo执行一切命令，当然，需要输入密码。 ","date":"2020-04-08","objectID":"/arch-install/:4:3","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装图像界面 安装显卡驱动 你可以参照上表安装适合的显卡驱动，比如 Intel 的集成显卡就要安装： sudo pacman -S xf86-video-intel 安装Xorg X.Org项目提供了X Window系统的开源实现，是几乎一切桌面用户程序的必备条件。 sudo pacman -S xorg 安装桌面环境 Linux 不像 Windows 或者 MacOS ，它拥有无数不同的桌面环境，这些桌面环境各有特点，从只有窗口管理器的 i3wm 和 Openbox ，到轻量级的 Xfce 、LXDE 和 LXQt、国人开发的 Deepin Desktop Environment ，再到最知名的 GNOME 和 KED ，可以说是数不胜数。其中我最喜欢的是 KED(Plasma)，它几乎不需要怎么配置就有着非常棒的显示效果，可定制项多，自带的工具也非常的齐全方便。所以接下来就以它为例。 准确来说 KED 并不是一个桌面环境，而是一个由 Plasma 桌面环境、库、框架 (KDE Frameworks)和应用组成的软件项目，包含了大量应用程序。其中桌面环境叫做 Plasma ，而其他应用程序可以在 kde-applications 包组中找到。 你可以直接执行以下命令来安装它们全部： sudo pacman -S plasma kde-applications 不过我觉得这有点太重了，kde-applications 中有不少软件我是用不上的。所以我选择了只安装 plasma ，再手动安装其他需要的软件。我安装的程序主要如下： sudo pacman -S plasma ark dolphin gwenview kdf konsole spectacle yakuake 它们依次是桌面环境、压缩包管理器、文件管理器、图像查看器、磁盘空间查看器、终端模拟器、截图工具、下拉式终端。 安装显示管理器 显示管理器可以帮助我们不需要每次手动启动桌面环境，图形化完成登录等操作。最常用的显示管理器是 SDDM（也是KED的默认显示管理器）。 sudo pacman -S sddm 安装完成后我们需要让它开机自动启动： sudo systemctl enable sddm 重启进入图形化界面 最后我们只要运行reboot重启即可进入图形化界面了！ ","date":"2020-04-08","objectID":"/arch-install/:4:4","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"开始使用 ","date":"2020-04-08","objectID":"/arch-install/:5:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"配置 pacman pacman 是 Arch 默认的包管理器，它有许多可自定义的选项，可以通过编辑/etc/pacman.conf进行修改，我进行的配置如下： 启用彩色输出：反注释Color 升级前对比版本：反注释VerbosePkgLists ","date":"2020-04-08","objectID":"/arch-install/:5:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"使用 ArchlinuxCN Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含中文用户常用软件、工具、字体/美化包等。我们可以通过编辑 /etc/pacman.conf 来添加它。 在 /etc/pacman.conf 文件末尾添加以下两行： [archlinuxcn] Server = https://repo.archlinuxcn.org/$arch 或者也可以使用清华大学开源软件镜像站提供的镜像： [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 之后安装 archlinuxcn-keyring 包导入 GPG key。 提示 如果安装 archlinuxcn-keyring 失败的话可以在/etc/pacman.conf最后面添加： SigLevel = Optional TrustAll ","date":"2020-04-08","objectID":"/arch-install/:5:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"使用 AUR Arch 用户软件仓库（Arch User Repository，AUR）是为用户而建、由用户主导的 Arch 软件仓库。提供了大量官方包之外的软件包，可以说它是 Arch 的灵魂之一，几乎所有 Linux 上有的软件都可以在它里面找到。 要安装 AUR 中的软件，基本操作是在 AUR 中搜索软件，然后使用git克隆源码，再使用makepkg生成安装包，最后使用pacman -U xxx.tar.gz安装包。这显然是很麻烦的，所以我们可以使用一些 AUR 助手（AUR helpers）来帮助我们安装，目前最为常用的是 yay 。 如果你添加了 ArchlinuxCN 源的话可以直接安装 yay 。 sudo pacman -S yay 否则需要手动安装： git clone https://aur.archlinux.org/yay-bin.git cd yay makepkg -si yay 兼容所有 pacman 的命令行，你可以直接像使用pacman一样使用它。 如果 AUR 源访问较慢，也可以使用以下命令切换到清华大学开源软件镜像站提供的镜像源。 yay --aururl \"https://aur.tuna.tsinghua.edu.cn\" --save ","date":"2020-04-08","objectID":"/arch-install/:5:3","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装中文字体 中文字体有很多种，常用的有文泉驿的开源字体和 Google 的 noto 字体，我使用的是noto 字体。 sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji 如果你在安装后发现部分界面字形为异体（日文）字形，可以参考 修正简体中文显示为异体（日文）字形。 ","date":"2020-04-08","objectID":"/arch-install/:5:4","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"安装中文输入法 中文输入法可以直接使用搜狗输入法。 如果添加了 ArchlinuxCN 源的话可以直接执行以下命令安装： sudo pacman -S fcitx-lilydjwg-git fcitx-sogoupinyin fcitx-qt5 如果是KDE桌面环境的话还应该安装： sudo pacman -S kcm-fcitx 安装完成后需要修改/etc/profile文件，在文件开头添加： export XMODIFIERS=\"@im=fcitx\" export GTK_IM_MODULE=\"fcitx\" export QT_IM_MODULE=\"fcitx\" ","date":"2020-04-08","objectID":"/arch-install/:5:5","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"软件推荐 最后再来推荐一些我常用的软件吧。 ","date":"2020-04-08","objectID":"/arch-install/:6:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"Zsh Bash 的替代者，支持丰富的插件和主题，可以说是最好的 Shell 之一。 配合 Oh My Zsh 和 Powerlevel10k 主题简直好用到飞起！ sudo pacman -S zsh oh-my-zsh-git zsh-autosuggestions zsh-syntax-highlighting zsh-theme-powerlevel10k 我常用的的插件如下： plugins=(git sudo sublime colored-man-pages pip command-not-found safe-paste extract z wd archlinux zsh-autosuggestions zsh-syntax-highlighting) ","date":"2020-04-08","objectID":"/arch-install/:6:1","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"办公 Markdown 编辑器：Typora Office：WPS 思维导图：XMind Zen 笔记：Leanote ","date":"2020-04-08","objectID":"/arch-install/:6:2","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"互联网 浏览器：Chrome 浏览器：FireFox 下载：uGet 下载：Aria2 比特币钱包：Electrum 网络抓包：Wireshark 云盘：坚果云 ","date":"2020-04-08","objectID":"/arch-install/:6:3","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"影音图像 图像处理：GIMP 视频播放器：VLC ","date":"2020-04-08","objectID":"/arch-install/:6:4","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"文字编辑 Sublime Text Atom Visual Studio Code ","date":"2020-04-08","objectID":"/arch-install/:6:5","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Linux"],"content":"参考 Arch Linux Wiki Installation guide Arch Linux Wiki General recommendations 以官方Wiki的方式安装ArchLinux ArchLinux安装后的必须配置与图形界面安装教程 Arch Linux上搜狗输入法无法输入的解决方法 ","date":"2020-04-08","objectID":"/arch-install/:7:0","tags":["Linux","Arch"],"title":"Arch Linux 安装记录","uri":"/arch-install/"},{"categories":["Hexo"],"content":"Hello World! 今天这个博客正式建立了！ ","date":"2020-04-06","objectID":"/hello-world/:0:0","tags":["Blog"],"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"$$ e^{i \\pi}+1=0 $$ Euler's formula Wir müssen wissen. Wir werden wissen. 我们必须知道，我们必将知道！ 大卫·希尔伯特(David Hilbert) 基础信息 学生 热爱生活 热爱科技 Github：https://github.com/st1020 Wikidot：http://st1020.wikidot.com 专业知识 Python C Learning… 兴趣爱好 编程 摄影 阅读 动漫 科幻 完成项目 Stone Termux管理工具 (Stone-Termux-Tool) Termux-Arch Lcmt (A Linux Container Manager On Termux) Doing… ","date":"2020-04-05","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]